---
keywords: fastai
description: A thorough comparison between DL algorithms and LightGBM for tabular data for classification and regression problems
title: "pytorch-widedeep, deep learning for tabular data IV: Deep Learning vs LightGBM"
author: Javier Rodriguez
toc: true 
badges: true
comments: true
nb_path: _notebooks/2021-05-28-pytorch-widedeep_iv.ipynb
layout: notebook
---

<!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2021-05-28-pytorch-widedeep_iv.ipynb
-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Here we go with yet another post in the series. I started planning this posts a few months ago, as soon as I released what it was the last beta version (<code>0.4.8</code>) of the library <a href="https://github.com/jrzaurin/pytorch-widedeep">pytorch-widedeep</a>. However, since then, a few things took priority, which meant that to run the hundreds of experiments that I run (probably over 1500), took me considerably more time than I expected. Nevertheless, here we are.</p>
<p>Let me start by saying thanks to the guys at the <a href="https://aws.amazon.com/developer/community/community-builders/">AWS community builders</a> and specially to <a href="https://www.linkedin.com/in/cameronperon/">Cameron</a>, for making my life a lot easier around AWS.</p>
<p>All the Deep Learning models for this project were run on a <code>p2.xlarge</code> instance and all the <code>LightGBM</code> experiments were run on my Mac <code>Mid 2015</code>.</p>
<p>Once the proper acknowledgments have been made, let me tell you a bit about the context of all those experiments and eventually this post.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="1.-Introduction:-why-all-this?">1. Introduction: why all this?<a class="anchor-link" href="#1.-Introduction:-why-all-this?"> </a></h2><p>Well, through the last couple of years, and in particular during the last year, I have been putting a lot of effort in improving <a href="https://github.com/jrzaurin/pytorch-widedeep">pytorch-widedeep</a>. This has been <strong>really</strong> entertaining, and I have learned a lot. However, as I was adding models to the library, especially for the tabular component (see <a href="https://pytorch-widedeep.readthedocs.io/en/latest/model_components.html">here</a>), I wondered if there was a purpose to it, other than learning those models themselves. You see, I am a scientist in education and I spent over a decade in academia. There we used to do <em>a lot</em> of not-very-useful things, cool (sometimes), but not very useful. One of the aspects that drove me to the private sector a few years back now was the search for a sense of "usefulness", where I could build things that have a scientific aspect and at the same time are useful. With that in mind, I wanted the library to be, forgive the redundancy, useful. Here the adjective "useful" can mean a number of things. It could mean directly using the library, or fork the repo and use the code, or just copy and paste some portion of the code for a given project. However eventually, a question that I wanted to answer was: <em>do these models compare well or even improve the performance of other more "standard" models like GBMs?</em>. Note that I write "<em>a question</em>" and not "<em>the question</em>". More on this later in the post.</p>
<p>Of course, I am not the first to compare Deep Learning (hereafter DL) approaches with GBMs for tabular data, and I won't be the last. In fact, by the time I am writing these lines, a new paper: <a href="https://arxiv.org/pdf/2106.03253.pdf">Tabular Data: Deep Learning is Not All You Need</a> [1] was published. This post and that paper are certainly very similar, and the conclusion entirely consistent. However, there are some differences. The compare DL algorithms against <code>XGBoost</code> [2] and <code>CatBoost</code> [3], while I use <code>LightGBM</code> [4] (see Section 2.3 for an explanation on the use of this algorithm). Also, I would say that three of the four datasets that I use here are a bit more challenging that the datasets in their paper, but that might be just my perception. Finally, with the exception of <code>TabNet</code>, the DL models I use here and those in that paper are different. Nonetheless, in the Conclusion section I will write some thoughts on ways to tackle this benchmark/testing exercises.</p>
<p>Aside from that paper, in <em>all</em> papers where they release new models there are often comprehensive comparisons between DL architectures and GBMs. My main caveats with some of these publications are the following: I often do not manage to reproduce the results in the paper (which of course might be my fault) and I often find that the effort placed in optimizing the DL models is a bit more "<em>intense</em>" than that for the GBMs. Last but not least, the lack of consistency in the results tables in some papers is, sometimes, confusing. For example, Paper A will use DL Model A to find that performs better than all GBMs, normally <code>XGBoost</code>, <code>Catboost</code> and <code>LightGBM</code>. Then Paper B will come with a new DL Model B that will also perform better than all GBMs, but in their paper it turns out that Model A does not beat GBMs anymore.</p>
<p>Considering all that, I decided to use <a href="https://github.com/jrzaurin/pytorch-widedeep">pytorch-widedeep</a> and run a sizable set of experiments comprising different DL models for tabular data and <code>LightGBM</code>.</p>
<p>Before I move on let me comment on the code "quality" in that repo. One has to bear in mind that the goal here is to test algorithms in a rigorous manner, and not to write production code. If you wanted to see better code you can go to the <a href="https://github.com/jrzaurin/pytorch-widedeep">pytorch-widedeep</a> itself or maybe some other of my repos. Just saying in case some "purist" is tempted to waste universe's time.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="2.-Datasets-and-Models">2. Datasets and Models<a class="anchor-link" href="#2.-Datasets-and-Models"> </a></h2><p>For the experiments here I have used four datasets and four DL models.</p>
<h3 id="2.1-Datasets">2.1 Datasets<a class="anchor-link" href="#2.1-Datasets"> </a></h3><ol>
<li><a href="https://archive.ics.uci.edu/ml/datasets/adult">Adult Census</a> (binary classification)        </li>
<li><a href="https://archive.ics.uci.edu/ml/datasets/Bank+Marketing">Bank Marketing</a> (binary classification)</li>
<li><a href="https://www.kaggle.com/neomatrix369/nyc-taxi-trip-duration-extended">NYC taxi ride duration</a> (regression)</li>
<li><a href="https://archive.ics.uci.edu/ml/datasets/Facebook+Comment+Volume+Dataset">Facebook Comment Volume</a> (regression)</li>
</ol>
<p>The bash script <code>get_data.sh</code> in the <a href="https://github.com/jrzaurin/tabulardl-benchmark">repo</a> has all the info you need to get those datasets in case you wanted to explore them yourself. Of course, all the code used to run the experiments and reproduce the results is also available in that repo.</p>
<p>Here are some basic information about the datasets:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="n">basic_info</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">&quot;../../tabulardl-benchmark/raw_data/basic_stats_df.csv&quot;</span><span class="p">)</span>
<span class="n">basic_info</span><span class="p">[</span><span class="n">basic_info</span><span class="o">.</span><span class="n">Dataset</span> <span class="o">!=</span> <span class="s2">&quot;airbnb&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Dataset</th>
      <th>n_rows</th>
      <th>n_cols</th>
      <th>objective</th>
      <th>neg_pos_ratio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>adult</td>
      <td>45222</td>
      <td>15</td>
      <td>binary_classification</td>
      <td>0.3295</td>
    </tr>
    <tr>
      <th>1</th>
      <td>bank_marketing</td>
      <td>41188</td>
      <td>20</td>
      <td>binary_classification</td>
      <td>0.1270</td>
    </tr>
    <tr>
      <th>2</th>
      <td>nyc_taxi</td>
      <td>1458644</td>
      <td>26</td>
      <td>regression</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>facebook_comments_vol</td>
      <td>199029</td>
      <td>54</td>
      <td>regression</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Table 1</strong>. Basic information for the datasets used in this post</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>There are reasons why I choose those datasets.</p>
<p>In general, I looked for a binary, multi-class and regression datasets that had a good number of, if not dominated by categorical features. This is because in my experience, DL models for tabular data become more useful and competitive in sizeable datasets where categorical features are present (although [5] suggest that better results are obtained encoding numerical features as well) and moreover if these categorical features have a lot of categories. This is because the embeddings acquire a more significant value, i.e. we learn representations of those categorical features that encode relationships with all other features and also the target for a specific dataset. Note that this does not happen when using GBMs. Even if one used <a href="https://maxhalford.github.io/blog/target-encoding/">target encoding</a>, in reality there is not much of a learning element there (still useful of course).</p>
<p>Of course, one could take datasets that are dominated by numerical features and bin them somehow to turn them into categorical. However, this seemed a bit too "forced" for me. With the idea of keeping the content of this post as close as possible to real use cases, it is hard for me to think of many "real world" scenarios where we are provided with datasets dominated by numerical features that are then turned/binned into categorical before being fed to an algorithm. In other words, I did not want to consider datasets where I had to bin the numerical features into categorical just to compare GBMs and DL models.</p>
<p>On the other hand, I also looked for datasets that were already familiar to me or did not required too much feature engineering to get to a stage where the data could be passed to a model. This way I could perhaps save some time on that aspect and focus a bit more on the experimentation, since I intended to run a large number of experiments. Finally I looked for datasets that, to some extent, resemble as much as possible to datasets that one would find in the "real world", but had a tractable size so I could experiment within a reasonable time frame.</p>
<p>While I did manage to find suitable datasets for binary classification and regression, and I did not find datasets that I particularly liked in the case of multi-class classification (if anyone has any suggestion, please comment below and I am happy to give it a go). Perhaps I will include the <a href="https://archive.ics.uci.edu/ml/datasets/covertype">CoverType</a> dataset in the future, but the one at the UCI ML repository, not the Kaggle's balanced version. For now, I will move on with those four enumerated above. Let me briefly comment on each dataset.</p>
<p>I would refer to the <em>Adult Census dataset</em> as the "<em>easiest dataset</em>", in the sense that simple models (i.e. a Naive Bayes classifier) will already lead to accuracies of $\sim$ 84$\%$ without any feature engineering. Personally, I normally don't find these nice datasets in the real-world. However, it is one of the most popular and well known datasets for ML tutorials, posts etc, and I eventually decided to include it.</p>
<p>The <em>Bank Marketing</em> dataset is also well known. This data is related with direct marketing campaigns based on phone calls, trying to predict whether or not a client will subscribe to a product. In this case it is important to mention a couple of relevant aspects. In the first place I used the <a href="https://archive.ics.uci.edu/ml/datasets/Bank+Marketing">original dataset</a>, which is a bit imbalanced (positive to negative class ratio is 0.127). Secondly, you might look around and find that some people obtained better results that those I will show later in the post. All such cases that I found use either a balanced dataset from Kaggle, a feature called <code>duration</code>, or both. The <code>duration</code> feature, which refers to the duration of the call, is something you know <strong>after</strong> the call and highly affects the target. Therefore, I have not used it in my experiments. This dataset resembles more a real use case than the adult dataset in the sense that the data is imbalanced and the prediction is not an easy task at all. Still, the data size is small and is not that imbalanced.</p>
<p>The <em>NYC taxi ride duration</em> dataset is also well known and is the largest of all datasets I used. Here our goal is to predict the total ride duration of taxi trips in New York City. Instead of getting the dataset from the <a href="https://www.kaggle.com/c/nyc-taxi-trip-duration">Kaggle site</a> I manually downloaded an extended version from <a href="https://www.kaggle.com/neomatrix369/nyc-taxi-trip-duration-extended">here</a>, where all the feature engineering had already been done.</p>
<p>Finally the <em>Facebook Comment Volume</em> dataset was another ideal candidate, since it has a good size and all the feature engineering was done for me. Our goal here is to predict the comment volume that posts will receive. In fact this dataset was originally used to compare decision trees versus neural networks. A very detailed description of the dataset and the pre-processing can be found in the <a href="https://uksim.info/uksim2015/data/8713a015.pdf">original publication</a> [6]. In particular, I used their training Variant - 5 dataset for the experiments in this post, which has 199029 rows and 54 columns.</p>
<p>All the code for the data preparation steps, before the data is fed to the algorithms can be found <a href="https://github.com/jrzaurin/tabulardl-benchmark/tree/master/prepare_datasets">here</a></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="2.2.-The-DL-Models">2.2. The DL Models<a class="anchor-link" href="#2.2.-The-DL-Models"> </a></h3><p>As I mentioned earlier in the post, all DL models were run via <a href="https://github.com/jrzaurin/pytorch-widedeep">pytorch-widedeep</a>. This library offers four wide and deep model <a href="https://pytorch-widedeep.readthedocs.io/en/latest/model_components.html">components</a>: <code>wide</code>, <code>deeptabular</code>, <code>deeptext</code>, <code>deepimage</code>. Let me briefly comment on each one of them. For more details, please see the <a href="https://jrzaurin.github.io/infinitoml/">companion posts</a>, the <a href="https://pytorch-widedeep.readthedocs.io/en/latest/model_components.html">documentation</a> or the <a href="https://github.com/jrzaurin/pytorch-widedeep/tree/tabnet/pytorch_widedeep/models">source code</a> itself.</p>
<ol>
<li><code>wide</code>: this is just a linear model implemented via an <code>Embedding</code> layer</li>
</ol>
<ol>
<li><p><code>deeptabular</code>: this component will take of the "standard" tabular data and has 4 alternatives</p>
<p>2.1 <code>TabMlp</code>: a simple standard MLP. Very similar to, for example, the <a href="https://docs.fast.ai/tabular.learner.html">tabular api</a> implementation in the fastai library.</p>
<p>2.2 <code>TabResnet</code>: similar to the MLP but instead of dense layers I use Resnet blocks.</p>
<p>2.3 <code>Tabnet</code>[7]: this is a very interesting implementation. It is hard to explain it in a few sentences., therefore I strongly suggest reading the <a href="https://arxiv.org/abs/1908.07442">paper</a>. <code>Tabnet</code> is meant to be competitive with GBMs and offers model interpretability via feature importance. <code>pytorch-widedeep</code>'s implementation of Tabnet is fully based on the fantastic <a href="https://github.com/dreamquark-ai/Tabnet">implementation</a> by the guys at dreamquark-ai, therefore, <strong>ALL</strong> credit to them. Simply, I have adapted it to work within a Wide and Deep frame and added a couple of extra features, such as internal dropout in the GLU blocks and the possibility of not using ghost batch normalization [8].</p>
<p>Note that the original implementation allows training in two stages. First self-supervised training via a standard encoder-decoder approach and then supervised training or fine-tuning using only the encoder. Only the supervised training (i.e. the encoder) is implemented in <code>pytorch-widedeep</code>. The authors showed that unsupervised pre-training improves the performance mostly in low data sizes regime or when the unlabeled dataset is much larger than the labeled dataset. Therefore, if you are in one of those scenarios (or simply as a general statement), you better use <code>dreamquark-ai</code>'s implementation.</p>
<p>2.4.<code>TabTransformer</code>[9]: this is similar to <code>TabResnet</code>, but instead of Resnet blocks the authors used Transformer [10] blocks. Similar to the case of <code>Tabnet</code>, the <code>TabTransformer</code> allows for a two stages training process, unsupervised pre-training followed by supervised training or fine-tunning. <code>pytorch-widedeep</code>'s implementation of the <code>TabTransformer</code> is designed to be used in a "standard" way, i.e. supervised training. Note that consistent with the results of Sercan Ö. Arık, Tomas Pfister for <code>Tabnet</code>, the authors found that unsupervised pre-training improves the performance mostly in low data volume regime or when the unlabeled dataset is much larger than the labeled dataset. The <code>TabTransformer</code> implementation available in <code>pytorch-widedeep</code> is partially based on that at the <a href="https://github.com/awslabs/autogluon/tree/058398b61d1b2011f56a9dce149b0989adbbb04a/tabular/src/autogluon/tabular/models/tab_transformer">autogluon</a> library and that from Phil Wang <a href="https://github.com/lucidrains/tab-transformer-pytorch">here</a>.</p>
</li>
</ol>
<ol>
<li><code>deeptext</code>: standard text classifier/regressor comprised by a stack of RNNs (LSTMs or GRUs). In addition, there is the option to add a set of dense layers on top of the stack of RNNs and some other extra features. </li>
</ol>
<ol>
<li><code>deepimage</code>: standard image classifier/regressor using a pretrained network (in particular ResNets) or a sequence of 4 convolution layers. In addition, there is the option to add a set of dense layers on top of the stack of CNNs and some other extra features. </li>
</ol>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="2.3.-Why-LightGBM?">2.3. Why <code>LightGBM</code>?<a class="anchor-link" href="#2.3.-Why-LightGBM?"> </a></h3><p>If you have worked with me, or even have a chat with me about some ML project, you will know that one of my favorite algorithms is <code>LightGBM</code>. I have used is extensively. In fact, the last 3 ML systems that I have productionised all relied on <code>LightGBM</code>. It performs similarly, when not better, than its brothers and sisters (e.g. <code>XGBoost</code> or <code>CatBoost</code>), is significantly faster and offers support for categorical features (see <a href="https://www.tandfonline.com/doi/abs/10.1080/01621459.1958.10501479">here</a>. Although when it comes to support for categorical features <code>CatBoost</code> is probably the superior solution). In additions, offers the usual flexibility and performance of GBMs.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="2.4.-Experiments-setup-and-other-considerations">2.4. Experiments setup and other considerations<a class="anchor-link" href="#2.4.-Experiments-setup-and-other-considerations"> </a></h3><p>As I mentioned earlier in the post, I run many experiments (not all were recorded and/or made it to the post) for the four datasets focusing on the different models available for the <code>deeptabular</code> component. All the experiments run can be found <a href="https://github.com/jrzaurin/tabulardl-benchmark/tree/master/run_experiments">here</a> in the repo.</p>
<p>The experiments not only considered different parameters for the models (i.e. number of units, layers, etc..) but also different optimizers, learning rate schedulers, and training processes. For example, all experiments where run with early stopping, with "<code>patience</code> of 30 epochs in most cases. I used three different optimizers (<code>Adam</code>[11], <code>AdamW</code>[12] and <code>RAdam</code>[13]) and three different learning rate schedulers (<code>ReduceLROnPlateau</code>, <code>OneCycleLR</code>[14], <code>CyclicLR</code>[15]). The following command corresponds to one of the experiments run:</p>
<div class="highlight"><pre><span></span>python adult/adult_tabmlp.py --mlp_hidden_dims <span class="o">[</span><span class="m">100</span>,50<span class="o">]</span> --mlp_dropout <span class="m">0</span>.2 --optimizer Adam --early_stop_patience <span class="m">30</span> --lr_scheduler CyclicLR --base_lr 5e-4 --max_lr <span class="m">0</span>.01 --n_cycles <span class="m">10</span> --n_epochs <span class="m">100</span> --save_results
</pre></div>
<p>That command above will run a <code>TabMlp</code> model for the adult dataset. Most <code>args</code> are straightforward to understand. Perhaps the only interesting aspect to comment is that this particular experiment was run with a <code>CyclicLR</code> scheduler, where the learning rate oscillates between 0.0005 to 0.01, 10 times over 100 epochs (i.e. a cycle every 10 epochs).</p>
<p>It is worth mentioning that when running the experiments, I assumed that there is an inherent hierarchy in the DL model parameters and training set ups. Therefore, rather than optimizing all parameters at once, I chose those that I considered more relevant and run experiments that reproduced that hierarchy. For example, when running a simple <code>MLP</code>, I assume that the number of neurons in the layers is a more important parameter than whether or not I use <code>BatchNorm</code> in the last layer. It might be, or surely it is, that the best thing to do is to optimize all parameters at once, but following this "hierarchical" approach also gave me a sense of how changing some individual parameters affected the performance of the model. Nonetheless, around 100 experiments were run per model and per dataset on average, so the exploration was relatively exhaustive (just relatively).</p>
<p>On the other hand <code>LightGBM</code> was optimized using <code>Optuna</code>[16], <code>Hyperopt</code>[17], or both and choosing the parameters that lead to the best metrics. All the code can be found <a href="https://github.com/jrzaurin/tabulardl-benchmark">here</a>. Note that the experiments, and the code in the repo, represent a very detailed and thorough tutorial on how to use <code>pytorch-widedeep</code> (if you wanted to use the library).</p>
<p>It is also worth mentioning that when running the experiment, the early stop criterion for both the DL models and <code>LightGBM</code> was based on the validation loss. Alternatively, one can monitor a metric, such as accuracy of the f1 score. Note that accuracy (or f1) and loss are not necessarily exactly inversely correlated. There might be edge cases where the algorithm is really unsure about some predictions (i.e. predictions are close to the metric threshold leading to high loss values) yet ends up making the right prediction (higher accuracy). Of course, ideally we want the algorithm to be sure and make the right predictions, but you know, the real world is messy and noisy. Nonetheless, out of curiosity, I tried to monitor metrics in some experiments. Overall, I did find that the results where consistent with those monitoring loss values, although slightly better metrics could be achieved in some cases.</p>
<p>Another relevant piece of information is related to the number of embeddings used to represent the categorical features. As one can imagine the amount of possibilities here is endless, and I had to find a way to consistently automate the process across all experiment. To that end I decided to use fastai's <a href="https://github.com/fastai/fastai/blob/90e009b90b9843dde8c02b0268ab9021ebef342f/fastai/tabular/model.py#L10">empirical rule of thumb</a>. For a given categorical feature, the number of embeddings will be:</p>
$$
n_{embed} = min\big(600, int(1.6 \times n_{cat}^{0.56})\big)
$$<p>The exception is the <code>TabTransformer</code>. The <code>TabTransformer</code> treats the categorical features as if they were part of a sequence (i.e. contextual) where the sequence order is irrelevant, i.e. no positional encoding needed. Therefore, rather than stack them "one besides another", they are stacked "one on top of each other". This means that all categorical features must have the same dimensions. Note that this is bit of an inconvenient when we have a wide range of categories for the categorical features in the dataset.</p>
<p>For example, let's say we have a dataset with just 2 categorical features having 50 and 3 different categories respectively. While using embeddings of 16 dimensions, for example, seems appropriate for the former, it certainly seems like an "over-representation" in the latter case. One could still use fastai's rule of thumb and pad the embeddings with lower dimension, but that would imply that some of the attention heads will be attending to zeros/nothing throughout the entire training process, which seems like a waste to me. Despite of this potential "waste", I am considering bringing this as an option for <code>pytorch-widedeep</code>'s <code>TabTransformer</code> implementation. In the meantime, "<em>all</em>" <code>TabTransformer</code> experiments were run with an additional set up where categorical features with a small number of categories were passed through the <code>wide</code> component.</p>
<p>Finally, for all experiments I used 80% of the data for training and 10% for validation/parameter tunning. Then these 2 datasets were combined in one last training run and the algorithm was tested on the remaining 10% of the data. The datasets were split at random unless there is a temporal component. In those cases I used chronological train/test split (note that in the case of the <em>Facebook Comment Volume</em> dataset I did not use the test set used in the paper. All train, validation and test datasets are splits of the Variant - 5 dataset described in the paper).</p>
<p>And that's all, without further ado, let's move to the results.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="3.-Results">3. Results<a class="anchor-link" href="#3.-Results"> </a></h2><p>The previous sections provide context to this "project" and details on the experiments that I did run. In this section I will simply show the top 5 results for all data and model combinations along with some comments when I consider necessary. The complete tables with the results for "<em>all</em>" experiments can be found <a href="https://github.com/jrzaurin/tabulardl-benchmark/tree/master/analyze_experiments/leaderboards">here</a>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="3.1-Adult-Census-Dataset">3.1 Adult Census Dataset<a class="anchor-link" href="#3.1-Adult-Census-Dataset"> </a></h3><h4 id="3.1.1-TabMlp">3.1.1 <code>TabMlp</code><a class="anchor-link" href="#3.1.1-TabMlp"> </a></h4>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>
<span class="n">adult_tabmlp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">TABLES_DIR</span> <span class="o">/</span> <span class="s2">&quot;adult_tabmlp.csv&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="n">adult_tabmlp</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>mlp_hidden_dims</th>
      <th>mlp_activation</th>
      <th>mlp_dropout</th>
      <th>mlp_batchnorm</th>
      <th>mlp_batchnorm_last</th>
      <th>mlp_linear_first</th>
      <th>embed_dropout</th>
      <th>lr</th>
      <th>batch_size</th>
      <th>weight_decay</th>
      <th>optimizer</th>
      <th>lr_scheduler</th>
      <th>base_lr</th>
      <th>max_lr</th>
      <th>div_factor</th>
      <th>final_div_factor</th>
      <th>n_cycles</th>
      <th>val_loss_or_metric</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>[400,200]</td>
      <td>relu</td>
      <td>0.5</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.1</td>
      <td>0.0010</td>
      <td>128</td>
      <td>0.0</td>
      <td>AdamW</td>
      <td>ReduceLROnPlateau</td>
      <td>0.0010</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.285664</td>
    </tr>
    <tr>
      <th>1</th>
      <td>[400,200]</td>
      <td>relu</td>
      <td>0.5</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.0</td>
      <td>0.0005</td>
      <td>128</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>CyclicLR</td>
      <td>0.0005</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>10.0</td>
      <td>0.285954</td>
    </tr>
    <tr>
      <th>2</th>
      <td>[100,50]</td>
      <td>relu</td>
      <td>0.2</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.0</td>
      <td>0.0004</td>
      <td>128</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>OneCycleLR</td>
      <td>0.0010</td>
      <td>0.01</td>
      <td>25</td>
      <td>1000.0</td>
      <td>5.0</td>
      <td>0.286010</td>
    </tr>
    <tr>
      <th>3</th>
      <td>[400,200]</td>
      <td>relu</td>
      <td>0.5</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.1</td>
      <td>0.0010</td>
      <td>128</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.0010</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.286126</td>
    </tr>
    <tr>
      <th>4</th>
      <td>[400,200]</td>
      <td>relu</td>
      <td>0.5</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.0</td>
      <td>0.0005</td>
      <td>128</td>
      <td>0.0</td>
      <td>RAdam</td>
      <td>CyclicLR</td>
      <td>0.0005</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>10.0</td>
      <td>0.286198</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Table 2</strong>. Results obtained for the Adult Census dataset using <code>TabMlp</code>.</p>
<p>Perhaps the first comment to make relates to the columns/parameters. It is straightforward to understand that not all parameters/columns apply to each experiment/row. For example, parameters/columns like <code>base_lr</code>, <code>max_lr</code>, <code>div_factor</code> or <code>final_div_factor</code> apply only when the learning rate scheduler is either <code>CyclicLR</code> or <code>OneCycleLR</code>.</p>
<p>On the other hand, the dense layers of the MLP are built using a very similar approach to that in the <code>fastai</code> library. This approach offers flexibility in terms of the operations that occur within each dense layer in the MLP (see <a href="https://pytorch-widedeep.readthedocs.io/en/latest/model_components.html#pytorch_widedeep.models.tab_mlp.TabMlp">here</a> for details). in that context thee columns <code>mlp_batchnorm_last</code> and <code>mlp_linear_first</code> set the order in which these operations occur. For example, if for a given dense layer we set <code>mlp_linear_first = True</code>, the implemented dense layer will look like this: <code>[LIN -&gt; ACT -&gt; DP]</code>. On the other hand, If <code>mlp_linear_first = False</code> then the dense layer will perform the operations in the following order: <code>[DP -&gt; LIN -&gt; ACT]</code>.</p>
<p>In the case of the Adult census dataset cyclic learning rates schedulers produce very good results. In fact, a one cycle learning rate with the adequate parameters would already lead to an acceptable validation loss in just one epoch (provided that the batch size is small enough), which perhaps illustrates that this dataset is not particularly difficult. Nonetheless the best result (by a negligible amount) was obtained with a <code>ReduceLROnPlateau</code> learning rate scheduler. This is actually common across all experiments for the different dataset and is also consistent with my experience running DL models in many different scenarios, for tabular data or text.  The <code>ReduceLROnPlateau</code> learning rate scheduler was run with "<em>patience</em>" of 10 epochs. This along with the <code>EarlyStopping</code> patience of 30 epochs means that, when <code>ReduceLROnPlateau</code> is used, the learning rate will be reduced 3 times before the experiment is forced to stop.</p>
<p>For full details on the experiments setup, the model implementation and the meaning behind each parameter/column please have a look to the two <code>pytorch-widedeep</code>'s <a href="https://pytorch-widedeep.readthedocs.io/en/latest/index.html">documentation</a> and the experiments <a href="https://github.com/jrzaurin/tabulardl-benchmark">repo</a>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="3.1.2-TabResnet">3.1.2 <code>TabResnet</code><a class="anchor-link" href="#3.1.2-TabResnet"> </a></h4>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>
<span class="n">adult_tabresnet</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">TABLES_DIR</span> <span class="o">/</span> <span class="s2">&quot;adult_tabresnet.csv&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="n">adult_tabresnet</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>blocks_dims</th>
      <th>blocks_dropout</th>
      <th>mlp_hidden_dims</th>
      <th>mlp_activation</th>
      <th>mlp_dropout</th>
      <th>mlp_batchnorm</th>
      <th>mlp_batchnorm_last</th>
      <th>mlp_linear_first</th>
      <th>embed_dropout</th>
      <th>lr</th>
      <th>batch_size</th>
      <th>weight_decay</th>
      <th>optimizer</th>
      <th>lr_scheduler</th>
      <th>base_lr</th>
      <th>max_lr</th>
      <th>div_factor</th>
      <th>final_div_factor</th>
      <th>n_cycles</th>
      <th>val_loss_or_metric</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>same</td>
      <td>0.5</td>
      <td>None</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.1</td>
      <td>0.0004</td>
      <td>32</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>OneCycleLR</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>1000.0</td>
      <td>5.0</td>
      <td>0.284989</td>
    </tr>
    <tr>
      <th>1</th>
      <td>same</td>
      <td>0.5</td>
      <td>None</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.0</td>
      <td>0.0004</td>
      <td>32</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>OneCycleLR</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>1000.0</td>
      <td>5.0</td>
      <td>0.285316</td>
    </tr>
    <tr>
      <th>2</th>
      <td>same</td>
      <td>0.5</td>
      <td>None</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.1</td>
      <td>0.0004</td>
      <td>128</td>
      <td>0.0</td>
      <td>AdamW</td>
      <td>OneCycleLR</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>1000.0</td>
      <td>5.0</td>
      <td>0.285449</td>
    </tr>
    <tr>
      <th>3</th>
      <td>same</td>
      <td>0.5</td>
      <td>None</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.1</td>
      <td>0.0004</td>
      <td>64</td>
      <td>0.0</td>
      <td>AdamW</td>
      <td>OneCycleLR</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>1000.0</td>
      <td>5.0</td>
      <td>0.285453</td>
    </tr>
    <tr>
      <th>4</th>
      <td>same</td>
      <td>0.5</td>
      <td>None</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.1</td>
      <td>0.0004</td>
      <td>32</td>
      <td>0.0</td>
      <td>AdamW</td>
      <td>OneCycleLR</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>1000.0</td>
      <td>5.0</td>
      <td>0.285588</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Table 3</strong>. Results obtained for the Adult dataset using <code>TabResnet</code>.</p>
<p><code>block_dim = same</code> in Table 3 indicate that the Resnet blocks, which are comprised by dense layers, have the same dimensions than the incoming embeddings (see <a href="https://github.com/jrzaurin/pytorch-widedeep/blob/tabnet/pytorch_widedeep/models/tab_resnet.py">here</a> for details on the implementation).</p>
<p>On the other hand, the <code>TabResnet</code> model offers the possibility of using an MLP "on top" of the Resnet blocks. When <code>mlp_hidden_dims = None</code> indicates that no MLP was used and the output of the last Resnet block was "plugged" directly into the output neuron. Therefore, as shown in Table 3, the top 5 results obtained using <code>TabResnet</code> correspond to architectures that have no MLP. In consequence, all MLP related parameters/columns are redundant for those experiments.</p>
<p>I find interesting that whether <code>Adam</code> or <code>AdamW</code>, the best results are obtained using <code>OneCycleLR</code>. When using this scheduler, I normally set the number of epochs to be in between 1 and 10. Normally I obtain the best results for a small number of epochs ($\leq 5$) and a small batch size, which implies that the increase/decrease of the learning rate will be more gradual (i.e. spread over a higher number of steps) as opposed as using large batch sizes. Finally note that the parameter/column <code>n_cycles</code> only apply to the <code>CyclicLR</code> scheduler. Since it is not used in any of the top 5 experiments it can be ignored in Table 3.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="3.1.3-Tabnet">3.1.3 <code>Tabnet</code><a class="anchor-link" href="#3.1.3-Tabnet"> </a></h4>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>
<span class="n">adult_tabnet</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">TABLES_DIR</span> <span class="o">/</span> <span class="s2">&quot;adult_tabnet.csv&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="n">adult_tabnet</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>n_steps</th>
      <th>step_dim</th>
      <th>attn_dim</th>
      <th>ghost_bn</th>
      <th>virtual_batch_size</th>
      <th>momentum</th>
      <th>gamma</th>
      <th>dropout</th>
      <th>embed_dropout</th>
      <th>lr</th>
      <th>batch_size</th>
      <th>weight_decay</th>
      <th>lambda_sparse</th>
      <th>optimizer</th>
      <th>lr_scheduler</th>
      <th>base_lr</th>
      <th>max_lr</th>
      <th>div_factor</th>
      <th>final_div_factor</th>
      <th>n_cycles</th>
      <th>val_loss_or_metric</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5</td>
      <td>32</td>
      <td>32</td>
      <td>False</td>
      <td>128</td>
      <td>0.98</td>
      <td>1.5</td>
      <td>0.1</td>
      <td>0.0</td>
      <td>0.03</td>
      <td>128</td>
      <td>0.0</td>
      <td>0.0001</td>
      <td>AdamW</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.291640</td>
    </tr>
    <tr>
      <th>1</th>
      <td>5</td>
      <td>64</td>
      <td>64</td>
      <td>False</td>
      <td>128</td>
      <td>0.98</td>
      <td>1.5</td>
      <td>0.2</td>
      <td>0.0</td>
      <td>0.03</td>
      <td>128</td>
      <td>0.0</td>
      <td>0.0001</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.293837</td>
    </tr>
    <tr>
      <th>2</th>
      <td>5</td>
      <td>32</td>
      <td>32</td>
      <td>False</td>
      <td>128</td>
      <td>0.98</td>
      <td>1.5</td>
      <td>0.1</td>
      <td>0.0</td>
      <td>0.03</td>
      <td>128</td>
      <td>0.0</td>
      <td>0.0001</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.293936</td>
    </tr>
    <tr>
      <th>3</th>
      <td>5</td>
      <td>64</td>
      <td>64</td>
      <td>False</td>
      <td>128</td>
      <td>0.98</td>
      <td>1.5</td>
      <td>0.2</td>
      <td>0.0</td>
      <td>0.03</td>
      <td>128</td>
      <td>0.0</td>
      <td>0.0001</td>
      <td>AdamW</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.294547</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>64</td>
      <td>64</td>
      <td>False</td>
      <td>128</td>
      <td>0.98</td>
      <td>1.5</td>
      <td>0.2</td>
      <td>0.0</td>
      <td>0.05</td>
      <td>128</td>
      <td>0.0</td>
      <td>0.0001</td>
      <td>RAdam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.296191</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Table 4</strong>. Results obtained for the Adult dataset using <code>Tabnet</code>.</p>
<p><code>Tabnet</code> has received some attention lately for being competitive with GBMs, and even over-performing them. In addition, it is a very elegant implementation that offers model interpretability via feature importance obtained using attention mechanisms.</p>
<p>The reality is that for the Adult Census dataset I obtain the worst loss values on the validation set (but as we will see later, not the worst metric). Maybe I simply missed "that precise" set of parameters that lead to better results. However, it is worth emphasizing that I have explored <code>Tabnet</code> with the same level of detail that any of the other 3 model alternatives.</p>
<p>On the other hand, it is interesting that, within all the experiments run, the best results are consistently obtained without Ghost batch normalization. Therefore, the parameter/column <code>virtual_batch_size</code> can be ignored in Table 4. Similarly, since the best results are all obtained using <code>ReduceLROnPlateau</code>, all the parameters related to cyclic learning rate schedulers can be ignored in Table 4.</p>
<p>Finally, consistent with some experiments I run in the past, the best results obtained using <code>RAdam</code> normally involve relatively high learning rates.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="3.1.4-TabTransformer">3.1.4 <code>TabTransformer</code><a class="anchor-link" href="#3.1.4-TabTransformer"> </a></h4>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>
<span class="n">adult_tabtransformer</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">TABLES_DIR</span> <span class="o">/</span> <span class="s2">&quot;adult_tabtransformer.csv&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="n">adult_tabtransformer</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>embed_dropout</th>
      <th>full_embed_dropout</th>
      <th>shared_embed</th>
      <th>add_shared_embed</th>
      <th>frac_shared_embed</th>
      <th>input_dim</th>
      <th>n_heads</th>
      <th>n_blocks</th>
      <th>dropout</th>
      <th>ff_hidden_dim</th>
      <th>transformer_activation</th>
      <th>mlp_hidden_dims</th>
      <th>mlp_activation</th>
      <th>mlp_batchnorm</th>
      <th>mlp_batchnorm_last</th>
      <th>mlp_linear_first</th>
      <th>with_wide</th>
      <th>lr</th>
      <th>batch_size</th>
      <th>weight_decay</th>
      <th>optimizer</th>
      <th>lr_scheduler</th>
      <th>base_lr</th>
      <th>max_lr</th>
      <th>div_factor</th>
      <th>final_div_factor</th>
      <th>n_cycles</th>
      <th>val_loss_or_metric</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.0</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>8</td>
      <td>16</td>
      <td>4</td>
      <td>4</td>
      <td>0.1</td>
      <td>NaN</td>
      <td>relu</td>
      <td>None</td>
      <td>relu</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.010</td>
      <td>128</td>
      <td>0.0</td>
      <td>RAdam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.287904</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.0</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>8</td>
      <td>16</td>
      <td>4</td>
      <td>4</td>
      <td>0.1</td>
      <td>NaN</td>
      <td>relu</td>
      <td>same</td>
      <td>relu</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.010</td>
      <td>128</td>
      <td>0.0</td>
      <td>RAdam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.288452</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.0</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>8</td>
      <td>16</td>
      <td>4</td>
      <td>4</td>
      <td>0.1</td>
      <td>NaN</td>
      <td>relu</td>
      <td>None</td>
      <td>relu</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>True</td>
      <td>0.010</td>
      <td>128</td>
      <td>0.0</td>
      <td>RAdam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.288797</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.0</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>8</td>
      <td>16</td>
      <td>4</td>
      <td>8</td>
      <td>0.2</td>
      <td>NaN</td>
      <td>relu</td>
      <td>None</td>
      <td>relu</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>True</td>
      <td>0.001</td>
      <td>128</td>
      <td>0.0</td>
      <td>AdamW</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.289188</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.0</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>8</td>
      <td>16</td>
      <td>2</td>
      <td>4</td>
      <td>0.1</td>
      <td>NaN</td>
      <td>relu</td>
      <td>None</td>
      <td>relu</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.010</td>
      <td>128</td>
      <td>0.0</td>
      <td>RAdam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.289371</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Table 5</strong>. Results obtained for the Adult Census dataset using the <code>TabTransformer</code>.</p>
<p>As with all the previous models, if you wanted details on the meaning of each parameter/column, please have a look to the [documentation] of the [source code] itself.</p>
<p>It is perhaps worth mentioning that when feed forward hidden dim (<code>ff_hidden_dim</code>) is set to <code>NaN</code> the model will default to a <code>ff_hidden_dim</code> value equal to 4 times the input embedding dimensions (16 in all the experiments/rows shown in the Table). This will result in a feed forward layer with dimensions <code>[ff_input_dim -&gt; 4 * ff_input_dim -&gt; ff_input_dim]</code>. Similarly, when <code>mlp_hidden_dims = None</code> the model will default to 4 times the input dimensions, resulting in an MLP of dimensions <code>[mlp_input_dim -&gt; 4 * mlp_input_dim -&gt; 2* mlp_input_dim -&gt; output_dim]</code>.</p>
<p>On In addition, and as mentioned before, the <code>TabTransformer</code> was also run with a set up that includes a <code>wide</code> component. This is specified by the <code>with_wide</code> parameter.</p>
<p>Is is worth noticing that the best loss values, which are similar to those of the rest of the DL models, are normally obtained using a <code>RAdam</code> optimizer.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="3.1.5-DL-vs-LightGBM">3.1.5 DL vs <code>LightGBM</code><a class="anchor-link" href="#3.1.5-DL-vs-LightGBM"> </a></h4><p>After having gone through the results obtained for each of the DL models, this is the moment of truth, let's see how the DL results compare with those obtained with <code>LightGBM</code>.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>
<span class="n">lightgbm_vs_dl_adult</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">TABLES_DIR</span> <span class="o">/</span> <span class="s2">&quot;lightgbm_vs_dl_adult.csv&quot;</span><span class="p">)</span>
<span class="n">lightgbm_vs_dl_adult</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>model</th>
      <th>acc</th>
      <th>runtime</th>
      <th>best_epoch_or_ntrees</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>lightgbm</td>
      <td>0.878178</td>
      <td>0.908639</td>
      <td>408.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>tabmlp</td>
      <td>0.872209</td>
      <td>205.357588</td>
      <td>62.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>tabtransformer</td>
      <td>0.871767</td>
      <td>288.640581</td>
      <td>32.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>tabnet</td>
      <td>0.870440</td>
      <td>422.296659</td>
      <td>26.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>tabresnet</td>
      <td>0.869777</td>
      <td>388.932547</td>
      <td>25.0</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Table 6</strong>. Results obtained for the Adult Census dataset using four DL models and <code>LightGBM</code>.</p>
<p>Let me emhpasise again that the metrics shown in Table 6 are <em>all</em> obtained, of course, for the test dataset. The <code>runtime</code> column shows the training time on the final train dataset (i.e. a dataset comprising 90% of the data) using the best parameters obtained during validation. The DL models where run on a <code>p2.xlarge</code> instance on AWS and all the <code>LightGBM</code> experiments were run on my Mac Mid 2015.</p>
<p>They are a few aspects worth commenting. In the first place, all DL models obtain results that are competitive with, but not better than, those of <code>LightGBM</code>. Secondly, the best performing DL model (by a rather marginal amount) is the simplest model, the <code>TabMlp</code>. And finally, the training time when using <code>LightGBM</code> is simply "<em>gigantically</em>" better than with any of the DL models.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="3.2-Bank-Marketing-Dataset">3.2 Bank Marketing Dataset<a class="anchor-link" href="#3.2-Bank-Marketing-Dataset"> </a></h3><p>Most of the comments in the previous section apply to the tables shown in this section.</p>
<p>Note that as I mentioned earlier in the post, the Bank Marketing dataset is slightly imbalanced. Therefore I also run some experiments using the <a href="https://arxiv.org/abs/1708.02002?source=post_page---------------------------">focal loss</a> [18] (which is accessible in <code>pytorch_widedeep</code> via a parameter or as a loss function input. See <a href="https://pytorch-widedeep.readthedocs.io/en/latest/trainer.html">here</a>). Overall, the results obtained where similar to, but not better than those without the focal loss. This is consistent with my experience with other datasets where I find that the focal loss leads to notably better results when the dataset is highly imbalanced (for example, around 2% positive to negative class ratio).</p>
<h4 id="3.2.1-TabMlp">3.2.1 <code>TabMlp</code><a class="anchor-link" href="#3.2.1-TabMlp"> </a></h4>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>
<span class="n">bank_marketing_tabmlp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">TABLES_DIR</span> <span class="o">/</span> <span class="s2">&quot;bank_marketing_tabmlp.csv&quot;</span><span class="p">)</span>
<span class="c1"># focal loss values are on a different scale</span>
<span class="n">bank_marketing_tabmlp</span> <span class="o">=</span> <span class="n">bank_marketing_tabmlp</span><span class="p">[</span><span class="n">bank_marketing_tabmlp</span><span class="o">.</span><span class="n">val_loss_or_metric</span> <span class="o">&gt;</span> <span class="mf">0.2</span><span class="p">]</span>
<span class="p">(</span><span class="n">bank_marketing_tabmlp</span>
 <span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;val_loss_or_metric&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
 <span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
 <span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>mlp_hidden_dims</th>
      <th>mlp_activation</th>
      <th>mlp_dropout</th>
      <th>mlp_batchnorm</th>
      <th>mlp_batchnorm_last</th>
      <th>mlp_linear_first</th>
      <th>embed_dropout</th>
      <th>lr</th>
      <th>batch_size</th>
      <th>weight_decay</th>
      <th>optimizer</th>
      <th>lr_scheduler</th>
      <th>base_lr</th>
      <th>max_lr</th>
      <th>div_factor</th>
      <th>final_div_factor</th>
      <th>n_cycles</th>
      <th>val_loss_or_metric</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>[100,50]</td>
      <td>relu</td>
      <td>0.1</td>
      <td>True</td>
      <td>True</td>
      <td>False</td>
      <td>0.1</td>
      <td>0.001</td>
      <td>512</td>
      <td>0.0</td>
      <td>AdamW</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.263838</td>
    </tr>
    <tr>
      <th>1</th>
      <td>[100,50]</td>
      <td>relu</td>
      <td>0.1</td>
      <td>True</td>
      <td>False</td>
      <td>True</td>
      <td>0.1</td>
      <td>0.001</td>
      <td>512</td>
      <td>0.0</td>
      <td>AdamW</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.263923</td>
    </tr>
    <tr>
      <th>2</th>
      <td>[100,50]</td>
      <td>relu</td>
      <td>0.1</td>
      <td>True</td>
      <td>True</td>
      <td>False</td>
      <td>0.1</td>
      <td>0.001</td>
      <td>512</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.264341</td>
    </tr>
    <tr>
      <th>3</th>
      <td>[100,50]</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.1</td>
      <td>0.001</td>
      <td>512</td>
      <td>0.0</td>
      <td>AdamW</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.264346</td>
    </tr>
    <tr>
      <th>4</th>
      <td>[100,50]</td>
      <td>relu</td>
      <td>0.1</td>
      <td>True</td>
      <td>False</td>
      <td>False</td>
      <td>0.1</td>
      <td>0.001</td>
      <td>512</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.264639</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Table 7</strong>. Results obtained for the Bank Marketing dataset using <code>TabMlp</code>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="3.2.2-TabResnet">3.2.2 <code>TabResnet</code><a class="anchor-link" href="#3.2.2-TabResnet"> </a></h4>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>
<span class="n">bank_marketing_tabresnet</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">TABLES_DIR</span> <span class="o">/</span> <span class="s2">&quot;bank_marketing_tabresnet.csv&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">bank_marketing_tabresnet</span> 
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>blocks_dims</th>
      <th>blocks_dropout</th>
      <th>mlp_hidden_dims</th>
      <th>mlp_activation</th>
      <th>mlp_dropout</th>
      <th>mlp_batchnorm</th>
      <th>mlp_batchnorm_last</th>
      <th>mlp_linear_first</th>
      <th>embed_dropout</th>
      <th>lr</th>
      <th>batch_size</th>
      <th>weight_decay</th>
      <th>optimizer</th>
      <th>lr_scheduler</th>
      <th>base_lr</th>
      <th>max_lr</th>
      <th>div_factor</th>
      <th>final_div_factor</th>
      <th>n_cycles</th>
      <th>val_loss_or_metric</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>same</td>
      <td>0.5</td>
      <td>None</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.0</td>
      <td>0.0004</td>
      <td>64</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>OneCycleLR</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>1000.0</td>
      <td>5.0</td>
      <td>0.265959</td>
    </tr>
    <tr>
      <th>1</th>
      <td>[50,50,50,50]</td>
      <td>0.2</td>
      <td>None</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.0</td>
      <td>0.0010</td>
      <td>512</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.266057</td>
    </tr>
    <tr>
      <th>2</th>
      <td>same</td>
      <td>0.5</td>
      <td>None</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.0</td>
      <td>0.0004</td>
      <td>64</td>
      <td>0.0</td>
      <td>RAdam</td>
      <td>OneCycleLR</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>1000.0</td>
      <td>5.0</td>
      <td>0.266301</td>
    </tr>
    <tr>
      <th>3</th>
      <td>same</td>
      <td>0.5</td>
      <td>None</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.0</td>
      <td>0.0004</td>
      <td>128</td>
      <td>0.0</td>
      <td>RAdam</td>
      <td>OneCycleLR</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>1000.0</td>
      <td>5.0</td>
      <td>0.266429</td>
    </tr>
    <tr>
      <th>4</th>
      <td>same</td>
      <td>0.5</td>
      <td>None</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.0</td>
      <td>0.0004</td>
      <td>128</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>OneCycleLR</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>1000.0</td>
      <td>5.0</td>
      <td>0.266728</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Table 8</strong>. Results obtained for the Bank Marketing dataset using <code>TabResnet</code>.</p>
<p>Again, and very interestingly, <code>RAdam</code> optimizer and <code>OneCycleLR</code> leading to some of the best results for this DL model.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="3.2.3-Tabnet">3.2.3 <code>Tabnet</code><a class="anchor-link" href="#3.2.3-Tabnet"> </a></h4>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>
<span class="n">bank_marketing_tabnet</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">TABLES_DIR</span> <span class="o">/</span> <span class="s2">&quot;bank_marketing_tabnet.csv&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">bank_marketing_tabnet</span> 
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>n_steps</th>
      <th>step_dim</th>
      <th>attn_dim</th>
      <th>ghost_bn</th>
      <th>virtual_batch_size</th>
      <th>momentum</th>
      <th>gamma</th>
      <th>dropout</th>
      <th>embed_dropout</th>
      <th>lr</th>
      <th>batch_size</th>
      <th>weight_decay</th>
      <th>lambda_sparse</th>
      <th>optimizer</th>
      <th>lr_scheduler</th>
      <th>base_lr</th>
      <th>max_lr</th>
      <th>div_factor</th>
      <th>final_div_factor</th>
      <th>n_cycles</th>
      <th>val_loss_or_metric</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5</td>
      <td>16</td>
      <td>16</td>
      <td>True</td>
      <td>128</td>
      <td>0.75</td>
      <td>1.5</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.03</td>
      <td>512</td>
      <td>0.0</td>
      <td>0.0001</td>
      <td>AdamW</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.271360</td>
    </tr>
    <tr>
      <th>1</th>
      <td>5</td>
      <td>16</td>
      <td>16</td>
      <td>True</td>
      <td>64</td>
      <td>0.25</td>
      <td>1.5</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.03</td>
      <td>512</td>
      <td>0.0</td>
      <td>0.0001</td>
      <td>AdamW</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.272235</td>
    </tr>
    <tr>
      <th>2</th>
      <td>5</td>
      <td>64</td>
      <td>64</td>
      <td>False</td>
      <td>128</td>
      <td>0.98</td>
      <td>1.5</td>
      <td>0.2</td>
      <td>0.0</td>
      <td>0.03</td>
      <td>128</td>
      <td>0.0</td>
      <td>0.0001</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.272639</td>
    </tr>
    <tr>
      <th>3</th>
      <td>5</td>
      <td>64</td>
      <td>64</td>
      <td>False</td>
      <td>128</td>
      <td>0.98</td>
      <td>1.5</td>
      <td>0.2</td>
      <td>0.0</td>
      <td>0.03</td>
      <td>128</td>
      <td>0.0</td>
      <td>0.0001</td>
      <td>AdamW</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.273802</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>16</td>
      <td>16</td>
      <td>True</td>
      <td>128</td>
      <td>0.98</td>
      <td>2.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.03</td>
      <td>512</td>
      <td>0.0</td>
      <td>0.0001</td>
      <td>AdamW</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.273859</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Table 9</strong>. Results obtained for the Bank Marketing dataset using <code>Tabnet</code>.</p>
<p>Note the top 5 results obtained with <code>Tabnet</code> in this case all have relatively high learning rate values (<code>lr = 0.03</code>). Also, and similar to the case of the Adult Census dataset, <code>Tabnet</code> produces the worst validation loss values.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="3.2.4-TabTransformer">3.2.4 <code>TabTransformer</code><a class="anchor-link" href="#3.2.4-TabTransformer"> </a></h4>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>
<span class="n">bank_marketing_tabtransformer</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">TABLES_DIR</span> <span class="o">/</span> <span class="s2">&quot;bank_marketing_tabtransformer.csv&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">bank_marketing_tabtransformer</span> 
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>embed_dropout</th>
      <th>full_embed_dropout</th>
      <th>shared_embed</th>
      <th>add_shared_embed</th>
      <th>frac_shared_embed</th>
      <th>input_dim</th>
      <th>n_heads</th>
      <th>n_blocks</th>
      <th>dropout</th>
      <th>ff_hidden_dim</th>
      <th>transformer_activation</th>
      <th>mlp_hidden_dims</th>
      <th>mlp_activation</th>
      <th>mlp_batchnorm</th>
      <th>mlp_batchnorm_last</th>
      <th>mlp_linear_first</th>
      <th>with_wide</th>
      <th>lr</th>
      <th>batch_size</th>
      <th>weight_decay</th>
      <th>optimizer</th>
      <th>lr_scheduler</th>
      <th>base_lr</th>
      <th>max_lr</th>
      <th>div_factor</th>
      <th>final_div_factor</th>
      <th>n_cycles</th>
      <th>val_loss_or_metric</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.0</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>8</td>
      <td>32</td>
      <td>8</td>
      <td>6</td>
      <td>0.1</td>
      <td>NaN</td>
      <td>relu</td>
      <td>None</td>
      <td>relu</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.001</td>
      <td>512</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.264646</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.0</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>8</td>
      <td>32</td>
      <td>8</td>
      <td>6</td>
      <td>0.1</td>
      <td>NaN</td>
      <td>relu</td>
      <td>None</td>
      <td>relu</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.001</td>
      <td>512</td>
      <td>0.0</td>
      <td>AdamW</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.264743</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.0</td>
      <td>False</td>
      <td>True</td>
      <td>False</td>
      <td>4</td>
      <td>16</td>
      <td>4</td>
      <td>6</td>
      <td>0.1</td>
      <td>NaN</td>
      <td>relu</td>
      <td>None</td>
      <td>relu</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.010</td>
      <td>128</td>
      <td>0.0</td>
      <td>RAdam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.266772</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.0</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>8</td>
      <td>32</td>
      <td>8</td>
      <td>6</td>
      <td>0.1</td>
      <td>NaN</td>
      <td>relu</td>
      <td>None</td>
      <td>relu</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.010</td>
      <td>1024</td>
      <td>0.0</td>
      <td>RAdam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.267205</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.0</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>8</td>
      <td>32</td>
      <td>8</td>
      <td>6</td>
      <td>0.1</td>
      <td>NaN</td>
      <td>relu</td>
      <td>None</td>
      <td>relu</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.001</td>
      <td>1024</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>0.267220</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Table 10</strong>. Results obtained for the Bank Marketing dataset using the <code>TabTransformer</code>.</p>
<p>It is perhaps worth noticing that consistent with some of the previous results, the best results obtained here using <code>RAdam</code> involve relatively high learning rates (a factor of 10 compared to those obtained using <code>Adam</code> or <code>AdamW</code>.)</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="3.2.5-DL-vs-LightGBM">3.2.5 DL vs <code>LightGBM</code><a class="anchor-link" href="#3.2.5-DL-vs-LightGBM"> </a></h4>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>
<span class="n">lightgbm_vs_dl_bank_marketing</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">TABLES_DIR</span> <span class="o">/</span> <span class="s2">&quot;lightgbm_vs_dl_bank_marketing.csv&quot;</span><span class="p">)</span>
<span class="n">lightgbm_vs_dl_bank_marketing</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>model</th>
      <th>f1</th>
      <th>auc</th>
      <th>runtime</th>
      <th>best_epoch_or_ntrees</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>tabresnet</td>
      <td>0.429799</td>
      <td>0.650147</td>
      <td>92.517464</td>
      <td>11.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>tabtransformer</td>
      <td>0.419971</td>
      <td>0.643972</td>
      <td>31.693761</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>tabmlp</td>
      <td>0.385542</td>
      <td>0.628082</td>
      <td>9.572095</td>
      <td>7.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>lightgbm</td>
      <td>0.385208</td>
      <td>0.626490</td>
      <td>0.461398</td>
      <td>57.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>tabnet</td>
      <td>0.308703</td>
      <td>0.594316</td>
      <td>77.878060</td>
      <td>13.0</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Table 11</strong>. Results obtained for the Bank Marketing dataset using four DL models and LightGBM.</p>
<p>I must admit that the results shown in Table 11 were surprising to me at first (to say the least). I went and run a few DL models again and <code>LightGBM</code> multiple times to double check, and finally concluded (spoiler alert) that this is going to be the only case among all experiments I run in this post where DL models perform better than <code>LightGBM</code>. In fact, if we joined the experiments here with my experience at work, this is the second time ever that I find that DL models perform better than <code>LightGBM</code> (more on this later). Furthermore, the improvement obtained using <code>TabResnet</code> or the <code>TabTransformer</code> is quite significant to the point that if this was a "real world" example, one might consider using a DL model and accept the trade between running time and success metric.</p>
<p>Of course one could go and dive a bit deeper into <code>LightGBM</code>, setting sample weights, or even using a custom loss, but the same can be said about the DL models. Therefore, and overall, I consider the comparison fair. However, I am so surprised that I consider the possibility that I might have a bug in the code that I have not been able to find. Therefore, if anyone goes through the code at some point and finds indeed a bug please let me know 🙂.</p>
<p>Finally, someone might feel disappointed by <code>Tabnet</code>'s performance, as I was. There is a possibility that I have not implemented it correctly, although the code is fully based on that from dreamquark-ai's implementation (<strong>ALL</strong> credit to them) and when tested with easier datasets, I obtain similar results to those with GBMs. I will come back to this point in the Conclusions section.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="3.3-NYC-Taxi-trip-duration">3.3 NYC Taxi trip duration<a class="anchor-link" href="#3.3-NYC-Taxi-trip-duration"> </a></h3><p>As I mentioned earlier this is the largest dataset, and in consequence, I experimented with larger batch sizes. While this might slightly change some of the individual results, I believe it will not change the overall conclusion in this section.</p>
<h4 id="3.3.1-TabMlp">3.3.1 <code>TabMlp</code><a class="anchor-link" href="#3.3.1-TabMlp"> </a></h4>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>
<span class="n">nyc_taxi_tabmlp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">TABLES_DIR</span> <span class="o">/</span> <span class="s2">&quot;nyc_taxi_tabmlp.csv&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="n">nyc_taxi_tabmlp</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>mlp_hidden_dims</th>
      <th>mlp_activation</th>
      <th>mlp_dropout</th>
      <th>mlp_batchnorm</th>
      <th>mlp_batchnorm_last</th>
      <th>mlp_linear_first</th>
      <th>embed_dropout</th>
      <th>lr</th>
      <th>batch_size</th>
      <th>weight_decay</th>
      <th>optimizer</th>
      <th>lr_scheduler</th>
      <th>base_lr</th>
      <th>max_lr</th>
      <th>div_factor</th>
      <th>final_div_factor</th>
      <th>n_cycles</th>
      <th>val_loss_or_metric</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>auto</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>True</td>
      <td>0.0</td>
      <td>0.01</td>
      <td>1024</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>79252.778571</td>
    </tr>
    <tr>
      <th>1</th>
      <td>auto</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>True</td>
      <td>0.0</td>
      <td>0.01</td>
      <td>1024</td>
      <td>0.0</td>
      <td>AdamW</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>79440.602511</td>
    </tr>
    <tr>
      <th>2</th>
      <td>auto</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.1</td>
      <td>0.01</td>
      <td>1024</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>79477.565346</td>
    </tr>
    <tr>
      <th>3</th>
      <td>auto</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.1</td>
      <td>0.01</td>
      <td>1024</td>
      <td>0.0</td>
      <td>AdamW</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>79710.855050</td>
    </tr>
    <tr>
      <th>4</th>
      <td>auto</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.0</td>
      <td>0.01</td>
      <td>1024</td>
      <td>0.0</td>
      <td>AdamW</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>80214.719727</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Table 12</strong>. Results obtained for the NYC Taxi trip duration dataset using the <code>TabMlp</code>.</p>
<p>The validation loss in this case is the <code>L2</code> loss (or <code>MSE</code>), therefore, the <code>RMSE</code> is just the squared root of that quantity. The standard deviation (std hereafter) of the target variable in the validation set is $\sim$599. Given that the std is the <code>RMSE</code> we would obtain if we always predicted the expected value, we can see that this is not a very powerful model, i.e. the task of predicting taxi trip duration is, indeed, relatively challenging.</p>
<p>Let's see how the other DL models perform.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="3.3.2-TabResnet">3.3.2 <code>TabResnet</code><a class="anchor-link" href="#3.3.2-TabResnet"> </a></h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Table 13</strong>. Results obtained for the NYC Taxi trip duration dataset using the <code>TabResnet</code>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="3.3.3--Tabnet">3.3.3  <code>Tabnet</code><a class="anchor-link" href="#3.3.3--Tabnet"> </a></h4>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>
<span class="n">nyc_taxi_tabnet</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">TABLES_DIR</span> <span class="o">/</span> <span class="s2">&quot;nyc_taxi_tabnet.csv&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="n">nyc_taxi_tabnet</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>n_steps</th>
      <th>step_dim</th>
      <th>attn_dim</th>
      <th>ghost_bn</th>
      <th>virtual_batch_size</th>
      <th>momentum</th>
      <th>gamma</th>
      <th>dropout</th>
      <th>embed_dropout</th>
      <th>lr</th>
      <th>batch_size</th>
      <th>weight_decay</th>
      <th>lambda_sparse</th>
      <th>optimizer</th>
      <th>lr_scheduler</th>
      <th>base_lr</th>
      <th>max_lr</th>
      <th>div_factor</th>
      <th>final_div_factor</th>
      <th>n_cycles</th>
      <th>val_loss_or_metric</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5</td>
      <td>8</td>
      <td>8</td>
      <td>False</td>
      <td>128</td>
      <td>0.75</td>
      <td>1.5</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.01</td>
      <td>1024</td>
      <td>0.0</td>
      <td>0.0001</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5</td>
      <td>144819.118973</td>
    </tr>
    <tr>
      <th>1</th>
      <td>5</td>
      <td>8</td>
      <td>8</td>
      <td>False</td>
      <td>128</td>
      <td>0.98</td>
      <td>1.5</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.01</td>
      <td>1024</td>
      <td>0.0</td>
      <td>0.0001</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5</td>
      <td>146057.807757</td>
    </tr>
    <tr>
      <th>2</th>
      <td>5</td>
      <td>8</td>
      <td>8</td>
      <td>False</td>
      <td>128</td>
      <td>0.50</td>
      <td>1.5</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.01</td>
      <td>1024</td>
      <td>0.0</td>
      <td>0.0001</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5</td>
      <td>146201.377121</td>
    </tr>
    <tr>
      <th>3</th>
      <td>5</td>
      <td>16</td>
      <td>16</td>
      <td>False</td>
      <td>128</td>
      <td>0.98</td>
      <td>1.5</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.01</td>
      <td>1024</td>
      <td>0.0</td>
      <td>0.0001</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5</td>
      <td>146461.734347</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>8</td>
      <td>8</td>
      <td>False</td>
      <td>128</td>
      <td>0.25</td>
      <td>1.5</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.01</td>
      <td>1024</td>
      <td>0.0</td>
      <td>0.0001</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5</td>
      <td>148636.888783</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Table 14</strong>. Results obtained for the NYC Taxi trip duration dataset using the <code>Tabnet</code>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="3.3.4--TabTransformer">3.3.4  <code>TabTransformer</code><a class="anchor-link" href="#3.3.4--TabTransformer"> </a></h4>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>
<span class="n">nyc_taxi_tabtransformer</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">TABLES_DIR</span> <span class="o">/</span> <span class="s2">&quot;nyc_taxi_tabtransformer.csv&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="n">nyc_taxi_tabtransformer</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>embed_dropout</th>
      <th>full_embed_dropout</th>
      <th>shared_embed</th>
      <th>add_shared_embed</th>
      <th>frac_shared_embed</th>
      <th>input_dim</th>
      <th>n_heads</th>
      <th>n_blocks</th>
      <th>dropout</th>
      <th>ff_hidden_dim</th>
      <th>transformer_activation</th>
      <th>mlp_hidden_dims</th>
      <th>mlp_activation</th>
      <th>mlp_batchnorm</th>
      <th>mlp_batchnorm_last</th>
      <th>mlp_linear_first</th>
      <th>with_wide</th>
      <th>lr</th>
      <th>batch_size</th>
      <th>weight_decay</th>
      <th>optimizer</th>
      <th>lr_scheduler</th>
      <th>base_lr</th>
      <th>max_lr</th>
      <th>div_factor</th>
      <th>final_div_factor</th>
      <th>n_cycles</th>
      <th>val_loss_or_metric</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.0</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>8</td>
      <td>16</td>
      <td>4</td>
      <td>4</td>
      <td>0.1</td>
      <td>NaN</td>
      <td>relu</td>
      <td>None</td>
      <td>relu</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.01</td>
      <td>1024</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5</td>
      <td>180162.408677</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.0</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>8</td>
      <td>16</td>
      <td>4</td>
      <td>4</td>
      <td>0.1</td>
      <td>NaN</td>
      <td>relu</td>
      <td>None</td>
      <td>relu</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.01</td>
      <td>256</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5</td>
      <td>186017.188849</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.0</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>8</td>
      <td>16</td>
      <td>4</td>
      <td>4</td>
      <td>0.1</td>
      <td>NaN</td>
      <td>relu</td>
      <td>None</td>
      <td>relu</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.01</td>
      <td>512</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5</td>
      <td>196144.067439</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.0</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>8</td>
      <td>32</td>
      <td>8</td>
      <td>4</td>
      <td>0.4</td>
      <td>NaN</td>
      <td>relu</td>
      <td>None</td>
      <td>relu</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.01</td>
      <td>1024</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5</td>
      <td>357869.370312</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.0</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>8</td>
      <td>64</td>
      <td>16</td>
      <td>4</td>
      <td>0.4</td>
      <td>NaN</td>
      <td>relu</td>
      <td>None</td>
      <td>relu</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.01</td>
      <td>512</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5</td>
      <td>357884.904297</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Table 15</strong>. Results obtained for the NYC Taxi trip duration dataset using the <code>TabTransformer</code>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="3.3.5-DL-vs-LightGBM">3.3.5 DL vs <code>LightGBM</code><a class="anchor-link" href="#3.3.5-DL-vs-LightGBM"> </a></h4>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>
<span class="n">lightgbm_vs_dl_nyc_taxy</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">TABLES_DIR</span> <span class="o">/</span> <span class="s2">&quot;lightgbm_vs_dl_nyc_taxi.csv&quot;</span><span class="p">)</span>
<span class="n">lightgbm_vs_dl_nyc_taxy</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>model</th>
      <th>rmse</th>
      <th>r2</th>
      <th>runtime</th>
      <th>best_epoch_or_ntrees</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>lightgbm</td>
      <td>262.709865</td>
      <td>0.804393</td>
      <td>42.721136</td>
      <td>504.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>tabmlp</td>
      <td>271.342218</td>
      <td>0.791327</td>
      <td>568.430923</td>
      <td>24.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>tabresnet</td>
      <td>292.890792</td>
      <td>0.756867</td>
      <td>471.264983</td>
      <td>24.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>tabtransformer</td>
      <td>336.582554</td>
      <td>0.678919</td>
      <td>5779.031367</td>
      <td>54.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>tabnet</td>
      <td>376.053004</td>
      <td>0.599198</td>
      <td>1844.472289</td>
      <td>15.0</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Table 16</strong>. Results obtained for the NYC Taxi trip duration dataset using four DL models and LightGBM.</p>
<p>The <code>TabTransformer</code> and <code>Tabnet</code> are, in this case, the models that have the worst performance. As I mentioned earlier I will reflect on potential reasons later in the Conclusion section.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="3.4-Facebook-comments-volume">3.4 Facebook comments volume<a class="anchor-link" href="#3.4-Facebook-comments-volume"> </a></h3><p>This is the last of the four datasets we will be discussing in this post, a second regression problem.</p>
<h4 id="3.4.1-TabMlp">3.4.1 <code>TabMlp</code><a class="anchor-link" href="#3.4.1-TabMlp"> </a></h4>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>
<span class="n">fb_comments_tabmlp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">TABLES_DIR</span> <span class="o">/</span> <span class="s2">&quot;fb_comments_tabmlp.csv&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="n">fb_comments_tabmlp</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>mlp_hidden_dims</th>
      <th>mlp_activation</th>
      <th>mlp_dropout</th>
      <th>mlp_batchnorm</th>
      <th>mlp_batchnorm_last</th>
      <th>mlp_linear_first</th>
      <th>embed_dropout</th>
      <th>lr</th>
      <th>batch_size</th>
      <th>weight_decay</th>
      <th>optimizer</th>
      <th>lr_scheduler</th>
      <th>base_lr</th>
      <th>max_lr</th>
      <th>div_factor</th>
      <th>final_div_factor</th>
      <th>n_cycles</th>
      <th>val_loss_or_metric</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>[100,50]</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>True</td>
      <td>0.0</td>
      <td>0.001</td>
      <td>512</td>
      <td>0.0</td>
      <td>RAdam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>32.593092</td>
    </tr>
    <tr>
      <th>1</th>
      <td>[100,50]</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.0</td>
      <td>0.001</td>
      <td>512</td>
      <td>0.0</td>
      <td>RAdam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>33.351503</td>
    </tr>
    <tr>
      <th>2</th>
      <td>[200, 100]</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.0</td>
      <td>0.001</td>
      <td>256</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>33.413959</td>
    </tr>
    <tr>
      <th>3</th>
      <td>[200, 100]</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.1</td>
      <td>0.001</td>
      <td>256</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>33.567868</td>
    </tr>
    <tr>
      <th>4</th>
      <td>[200, 100]</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.0</td>
      <td>0.001</td>
      <td>512</td>
      <td>0.0</td>
      <td>RAdam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>33.628375</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Table 17</strong>. Results obtained for the Facebook comments volume dataset using <code>TabMlp</code>.</p>
<p>As in the case of the NYC Taxi trip duration, the validation loss the <code>L2</code> loss. Therefore, following the same reasoning, we can see that the task of predicting the volume of facebook comments using this particular dataset
 is challenging.</p>
<p>Let's see how the other DL models perform.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="3.4.2--TabResnet">3.4.2  <code>TabResnet</code><a class="anchor-link" href="#3.4.2--TabResnet"> </a></h4>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>
<span class="n">fb_comments_tabresnet</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">TABLES_DIR</span> <span class="o">/</span> <span class="s2">&quot;fb_comments_tabresnet.csv&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="n">fb_comments_tabresnet</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>blocks_dims</th>
      <th>blocks_dropout</th>
      <th>mlp_hidden_dims</th>
      <th>mlp_activation</th>
      <th>mlp_dropout</th>
      <th>mlp_batchnorm</th>
      <th>mlp_batchnorm_last</th>
      <th>mlp_linear_first</th>
      <th>embed_dropout</th>
      <th>lr</th>
      <th>batch_size</th>
      <th>weight_decay</th>
      <th>optimizer</th>
      <th>lr_scheduler</th>
      <th>base_lr</th>
      <th>max_lr</th>
      <th>div_factor</th>
      <th>final_div_factor</th>
      <th>n_cycles</th>
      <th>val_loss_or_metric</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>[100, 100, 100]</td>
      <td>0.1</td>
      <td>None</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.0</td>
      <td>0.0005</td>
      <td>512</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>CyclicLR</td>
      <td>0.0005</td>
      <td>0.03</td>
      <td>25</td>
      <td>10000.0</td>
      <td>10.0</td>
      <td>34.497204</td>
    </tr>
    <tr>
      <th>1</th>
      <td>[100, 100, 100]</td>
      <td>0.1</td>
      <td>None</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.0</td>
      <td>0.0005</td>
      <td>512</td>
      <td>0.0</td>
      <td>AdamW</td>
      <td>CyclicLR</td>
      <td>0.0005</td>
      <td>0.03</td>
      <td>25</td>
      <td>10000.0</td>
      <td>10.0</td>
      <td>34.852034</td>
    </tr>
    <tr>
      <th>2</th>
      <td>[100, 100, 100]</td>
      <td>0.1</td>
      <td>None</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.0</td>
      <td>0.0005</td>
      <td>512</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>CyclicLR</td>
      <td>0.0005</td>
      <td>0.03</td>
      <td>25</td>
      <td>10000.0</td>
      <td>10.0</td>
      <td>34.950441</td>
    </tr>
    <tr>
      <th>3</th>
      <td>[100, 100, 100]</td>
      <td>0.1</td>
      <td>None</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.0</td>
      <td>0.0005</td>
      <td>512</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>CyclicLR</td>
      <td>0.0005</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>10.0</td>
      <td>35.166750</td>
    </tr>
    <tr>
      <th>4</th>
      <td>[100, 100, 100]</td>
      <td>0.1</td>
      <td>None</td>
      <td>relu</td>
      <td>0.1</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.0</td>
      <td>0.0005</td>
      <td>512</td>
      <td>0.0</td>
      <td>AdamW</td>
      <td>CyclicLR</td>
      <td>0.0005</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>10.0</td>
      <td>35.250297</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Table 18</strong>. Results obtained for the Facebook comments volume dataset using <code>TabResnet</code>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="3.4.3--Tabnet">3.4.3  <code>Tabnet</code><a class="anchor-link" href="#3.4.3--Tabnet"> </a></h4>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>
<span class="n">fb_comments_tabnet</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">TABLES_DIR</span> <span class="o">/</span> <span class="s2">&quot;fb_comments_tabnet.csv&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="n">fb_comments_tabnet</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>n_steps</th>
      <th>step_dim</th>
      <th>attn_dim</th>
      <th>ghost_bn</th>
      <th>virtual_batch_size</th>
      <th>momentum</th>
      <th>gamma</th>
      <th>dropout</th>
      <th>embed_dropout</th>
      <th>lr</th>
      <th>batch_size</th>
      <th>weight_decay</th>
      <th>lambda_sparse</th>
      <th>optimizer</th>
      <th>lr_scheduler</th>
      <th>base_lr</th>
      <th>max_lr</th>
      <th>div_factor</th>
      <th>final_div_factor</th>
      <th>n_cycles</th>
      <th>val_loss_or_metric</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5</td>
      <td>16</td>
      <td>16</td>
      <td>False</td>
      <td>128</td>
      <td>0.98</td>
      <td>1.5</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.03</td>
      <td>512</td>
      <td>0.0</td>
      <td>0.0001</td>
      <td>AdamW</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5</td>
      <td>35.812161</td>
    </tr>
    <tr>
      <th>1</th>
      <td>3</td>
      <td>16</td>
      <td>16</td>
      <td>False</td>
      <td>128</td>
      <td>0.98</td>
      <td>1.5</td>
      <td>0.2</td>
      <td>0.0</td>
      <td>0.03</td>
      <td>512</td>
      <td>0.0</td>
      <td>0.0001</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5</td>
      <td>37.641709</td>
    </tr>
    <tr>
      <th>2</th>
      <td>5</td>
      <td>16</td>
      <td>16</td>
      <td>False</td>
      <td>128</td>
      <td>0.98</td>
      <td>1.5</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.03</td>
      <td>512</td>
      <td>0.0</td>
      <td>0.0001</td>
      <td>AdamW</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5</td>
      <td>38.977099</td>
    </tr>
    <tr>
      <th>3</th>
      <td>5</td>
      <td>16</td>
      <td>16</td>
      <td>False</td>
      <td>128</td>
      <td>0.98</td>
      <td>1.5</td>
      <td>0.2</td>
      <td>0.0</td>
      <td>0.03</td>
      <td>512</td>
      <td>0.0</td>
      <td>0.0001</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5</td>
      <td>39.589880</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>16</td>
      <td>16</td>
      <td>False</td>
      <td>128</td>
      <td>0.98</td>
      <td>1.5</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.03</td>
      <td>256</td>
      <td>0.0</td>
      <td>0.0001</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.001</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5</td>
      <td>40.946173</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Table 19</strong>. Results obtained for the Facebook comments volume dataset using <code>Tabnet</code>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="3.4.4-TabTransformer">3.4.4 <code>TabTransformer</code><a class="anchor-link" href="#3.4.4-TabTransformer"> </a></h4>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>
<span class="n">fb_comments_tabtransformer</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">TABLES_DIR</span> <span class="o">/</span> <span class="s2">&quot;fb_comments_tabtransformer.csv&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="n">fb_comments_tabtransformer</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>embed_dropout</th>
      <th>full_embed_dropout</th>
      <th>shared_embed</th>
      <th>add_shared_embed</th>
      <th>frac_shared_embed</th>
      <th>input_dim</th>
      <th>n_heads</th>
      <th>n_blocks</th>
      <th>dropout</th>
      <th>ff_hidden_dim</th>
      <th>transformer_activation</th>
      <th>mlp_hidden_dims</th>
      <th>mlp_activation</th>
      <th>mlp_batchnorm</th>
      <th>mlp_batchnorm_last</th>
      <th>mlp_linear_first</th>
      <th>with_wide</th>
      <th>lr</th>
      <th>batch_size</th>
      <th>weight_decay</th>
      <th>optimizer</th>
      <th>lr_scheduler</th>
      <th>base_lr</th>
      <th>max_lr</th>
      <th>div_factor</th>
      <th>final_div_factor</th>
      <th>n_cycles</th>
      <th>val_loss_or_metric</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.0</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>8</td>
      <td>16</td>
      <td>2</td>
      <td>4</td>
      <td>0.1</td>
      <td>NaN</td>
      <td>relu</td>
      <td>None</td>
      <td>relu</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.0005</td>
      <td>1024</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>CyclicLR</td>
      <td>0.0005</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>10.0</td>
      <td>33.094625</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.0</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>8</td>
      <td>16</td>
      <td>2</td>
      <td>4</td>
      <td>0.1</td>
      <td>NaN</td>
      <td>relu</td>
      <td>None</td>
      <td>relu</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.0005</td>
      <td>4096</td>
      <td>0.0</td>
      <td>AdamW</td>
      <td>OneCycleLR</td>
      <td>0.0010</td>
      <td>0.01</td>
      <td>25</td>
      <td>1000.0</td>
      <td>5.0</td>
      <td>33.128317</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.0</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>8</td>
      <td>16</td>
      <td>2</td>
      <td>4</td>
      <td>0.1</td>
      <td>NaN</td>
      <td>relu</td>
      <td>None</td>
      <td>relu</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.0010</td>
      <td>1024</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.0010</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>33.217492</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.0</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>8</td>
      <td>16</td>
      <td>2</td>
      <td>4</td>
      <td>0.1</td>
      <td>NaN</td>
      <td>relu</td>
      <td>same</td>
      <td>relu</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.0010</td>
      <td>1024</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.0010</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>33.469849</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.0</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>8</td>
      <td>16</td>
      <td>4</td>
      <td>4</td>
      <td>0.1</td>
      <td>NaN</td>
      <td>relu</td>
      <td>None</td>
      <td>relu</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>0.0010</td>
      <td>1024</td>
      <td>0.0</td>
      <td>Adam</td>
      <td>ReduceLROnPlateau</td>
      <td>0.0010</td>
      <td>0.01</td>
      <td>25</td>
      <td>10000.0</td>
      <td>5.0</td>
      <td>33.794980</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Table 20</strong>. Results obtained for the Facebook comments volume dataset using the <code>TabTransformer</code>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="3.4.5--DL-vs-LightGBM">3.4.5  DL vs <code>LightGBM</code><a class="anchor-link" href="#3.4.5--DL-vs-LightGBM"> </a></h4>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>
<span class="n">lightgbm_vs_dl_fb_comments</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">TABLES_DIR</span> <span class="o">/</span> <span class="s2">&quot;lightgbm_vs_dl_fb_comments.csv&quot;</span><span class="p">)</span>
<span class="n">lightgbm_vs_dl_fb_comments</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>model</th>
      <th>rmse</th>
      <th>r2</th>
      <th>runtime</th>
      <th>best_epoch_or_ntrees</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>lightgbm</td>
      <td>5.528963</td>
      <td>0.823208</td>
      <td>6.525877</td>
      <td>687.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>tabmlp</td>
      <td>5.908498</td>
      <td>0.798103</td>
      <td>250.476762</td>
      <td>43.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>tabtransformer</td>
      <td>5.925587</td>
      <td>0.796933</td>
      <td>533.390816</td>
      <td>27.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>tabresnet</td>
      <td>6.213813</td>
      <td>0.776698</td>
      <td>70.466089</td>
      <td>9.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>tabnet</td>
      <td>6.428503</td>
      <td>0.761001</td>
      <td>935.020483</td>
      <td>59.0</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Table 21</strong>. Results obtained for the Facebook comments volume dataset using four DL models and LightGBM.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="4.-Summary">4. Summary<a class="anchor-link" href="#4.-Summary"> </a></h2><p>I have used four datasets and run over 1500 experiments (meaning runs with a parameter setup) comparing four DL models with <code>LightGBM</code>. This is a summary of some of the results.</p>
<ul>
<li><p><code>LightGBM</code> wins, and there was never a fight</p>
<p>With one exception, <code>LightGBM</code> performs better than the DL models, and that one exception is precisely that, exceptional. To the experiments run and discussed here I could add two occasions where I used DL for tabular data in companies that I worked with. In particular, the model that is referred here as <code>TabMlp</code> with a <code>wide</code> component in one case and on its own in the other.</p>
<p>The Wide &amp; Deep model was used in the context of a recommendation algorithm, shortly after the popular <a href="https://arxiv.org/abs/1606.07792">Wide and Deep</a> [19] paper was published in 2016. Back then I was using XGBoost to predict a measure of interest and rank offers based on that measure. The Wide and Deep model, implemented then with <code>Keras</code>, obtained slightly better MAP and NDCG than XGBoost (almost identical metrics were obtained when using just the deep component). Given the number of additional considerations that one needs to take into account as you go to production, we eventually used XGBoost.</p>
<p>In the second occasion, a more recent project, <code>TabMlp</code> on its own obtained very similar, but still lower RMSE and R2 values to those obtained using <code>LightGBM</code>. Even though <code>TabMLP</code>'s predictions were not directly used, we found the embeddings useful for a number of additional projects and we built a production system around <code>TabMlp</code>.</p>
<p>Up to this point, I have focused on performance as measured by success metrics. However, when it comes to training (and prediction) time, the difference is so significant that makes some of these algorithms, at this stage, just useful for research purposes and/or kaggle competitions. Don't get me wrong, you only push an industry technologically by challenging current solutions and established concepts. I am simply stating that at this stage, in a production environment, it would be hard to envision a robust system built around some of these algorithms. This is the reason why I wrote "<em>there was never a fight</em>". When you go live, quite often is not only about success metrics but also speed and resilience, and considering altogether it seems to me like DL models for tabular data are still a bit far from being normally inserted in productions systems (but read below).</p>
<p>Finally, you might read here and there that with the proper feature engineering, noise removal, balancing and "who-knows-what-else" DL models outperform GBMs. The truth is that in my experience is actually the opposite. This is also consistent with the results in some recent competitions. For example, in the <a href="https://recsys-twitter.com/">RecSys Challenge 2020</a> the guys at NVIDIA won using <a href="https://medium.com/rapids-ai/winning-solution-of-recsys2020-challenge-gpu-accelerated-feature-engineering-and-training-for-cd67c5a87b1f">clever featuring engineering</a> (e.g. target oriented encoding) "plugged" into XGBoost on steroids (or better, GPUs). I am not sure that using those features and a DL model would actually improve their results.</p>
<p>Overall, if I joined the results found this post, plus that I have found trying DL models on tabular data on real datasets in the industry, I can only conclude that DL models for tabular data "are not quite there yet" in terms of overall performance.</p>
</li>
</ul>
<ul>
<li><p><code>TabNet</code> and the <code>TabTransformer</code></p>
<p>One rather surprising results was the poor performance of <code>Tabnet</code>, and perhaps to a lesser extent, th e <code>TabTransformer</code>. In the case of <code>Tabnet</code> this seemed to me in contrast with the results in the original paper, and perhaps more in line with the results in the recent SAINT publication [5].</p>
<p>One possibility is that I have not found the right set of parameters that lead to good metrics. In fact, the amount of overfitting when using <code>Tabnet</code> and <code>TabTransformer</code> was very significant, higher than in the case of <code>TabResnet</code> and furthermore <code>TabMlp</code>. This makes me believe that if I find a better set of regularization parameters, I might be able to improve the results shown in the tables above. However, I should also say that given the good reception that these algorithms are having and the poor results I obtained, I placed a bit more emphasis in trying some additional parameters. Unfortunately, none of my attempts lead to a significant improvement.</p>
<p>A second possibility is, of course, that the implementation at <code>pytorch-widedeep</code> is wrong. I guess I will find this out as I keep releasing versions and using the package.</p>
<p>Overall, I find that <code>TabNet</code> is the worst performer (and the slowest) and I will devote some extra time in the coming weeks to see if this is related to the input parameters.</p>
</li>
</ul>
<ul>
<li><p>Simplicity over complexity.</p>
<p>It is interesting to see that overall, the DL algorithm that achieves similar performance to that of <code>LightGBM</code> is a simple MLP. By the time I write this, I wonder if this is somehow related to the emerging trend that is bringing MLPs back (e.g. [20], [21] or [22]), and the advent of more complex models is simply the result of hype instead of a proper exploration of current solutions.</p>
<p>Of course, for more complex models, there is more room for exploration and hyperparameter optimization. While this is something I intend to keep exploring, there is a moment in space and time that one wonders "<em>is this really worth it?</em>".</p>
<p>Let's see if I manage to answer this question in the next section</p>
</li>
</ul>
<h2 id="5-Conclusion">5 Conclusion<a class="anchor-link" href="#5-Conclusion"> </a></h2><p>When I started thinking of this post a part of me already knew that DL models were, overall, not a real challenge for <code>LightGBM</code>. If we focused only in performance metrics and running time the only possible conclusion is that DL models for tabular data are still not competition for GBMs in real-world environments. However, at this stage in the industry/market, is that really <em>the question</em> to answer? I don't think so.</p>
<p>This is not a competition, and it should not be, this should be a coalition. The question to answer is: "how DL models for tabular data can help in the industry and complement the current systems". Let's reflect a bit on this question.</p>
<p>In my experience, DL models on tabular data perform best when the data involves many categorical features and these have many categories themselves. In those scenarios, one could just try DL models with an initial aim of using directly the prediction. However, even if the prediction is eventually not used, the embeddings contain a wealth of useful information. Information on how each categorical feature interacts with each other and information on how each categorical features relates to the target variable (if you used SAINT's implementation this also applies to the numerical features). These embeddings can be used for a number of additional products.</p>
<p>For example, let's assume that you have a dataset with metadata for thousands of brands and prices for their corresponding products. Your task is to predict how the price changes over time (i.e. forecasting price). The embeddings for the categorical feature <code>brand</code> will give you information about how a particular brand relates to the rest of the columns in the dataset and the target (price). In other words, if given a brand you find the closest brands as defined by embeddings proximity you would be "naturally" and directly finding competitors within a given space.</p>
<p>In additions, GBMs do not allow for transfer learning, but DL models do. Furthermore, and as mentioned in the <code>TabNet</code> and the <code>TabTransformer</code> papers, self-supervised training leads to better performance in regimes where the data is low or the unlabeled dataset is much larger than the labeled dataset. Therefore, there are scenarios where DL models can be extremely useful.</p>
<p>For example, let's assume you have a large dataset for a given problem in one country but a much smaller dataset for the exact same problem in another country. Let's also asuume that the datasets are, column-wise, rather similar. One could train a DL model using the large dataset and "transfer the learnings" to the second, much smaller dataset with the hope of obtaining a much higher performance than just using that small dataset alone.</p>
<p>There are some other scenarios that I can think of, but I will leave it here. In general, I simply wanted to illustrate that, if you came here to enjoy the fact that GBMs perform better than DL models, I hope you enjoyed the ride (and that you start thinking in a good therapist), but in my opinion, that is not the point.</p>
<p><strong>In terms of metrics, GBMs perform better than DL models, that is correct, but the latter bring some functionalities to the table that GBMs don't have and therefore, complement them perfectly.</strong></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="6.-Future-Work">6. Future Work<a class="anchor-link" href="#6.-Future-Work"> </a></h2><p>I started thinking in this post months ago. Then some other things took priority in my life (plus a lot of work) and it became a bit of a longer journey. I now hope I can get a bit of help from very clever people in my team and improve the Tabular vs DL code in the repo, perhaps automating some processes so I can easily add more datasets in the future.</p>
<p>Also this has been a good test for the <code>pytorch-widedeep</code> library (if you like it, or find it useful, give it a star please 😊). All the links in this post point towards the <code>tabnet</code> branch in the repo, which is the most updated. During the next few days I will merge and release v1 of the package and then update the links and the post. From there, there are a series of algorithms we would like to bring (such as SAINT) and also add some different forms of training.</p>
<p>Beyond adding more algorithms to the library or improving the benchmark code, I wanted to close this with one final thought. As I mentioned in the beginning of the post, there is an element of inconsistency between papers. Different papers will find different results for all algorithms considered, GBMs or DL-based. When you read them one gets the feeling that there is some rush, some urgency to publish something that obtains SoTA. For someone like me, coming from a different background than computer science, this reminds me, in a sense, of my days as astronomer. For years then I found that most of the publications in my field where not very good, but since all that you are judged for are publications and citations, one would publish anything, and the faster, the better.</p>
<p>At this stage, leaving publications and citations aside, I think there is an opportunity for some of us, and some companies as well, to collaborate and properly benchmark DL algorithms for tabular data. I believe the potential of these algorithms in the industry is enormous and with proper benchmarks we could learn not only where they perform better, but how to use them more efficiently.</p>
<p>And that's it! if you made it to here I hope you enjoyed and/or find this useful.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="References">References<a class="anchor-link" href="#References"> </a></h2><p>[1] Tabular Data: Deep Learning is Not All You Need: Ravid Shwartz-Ziv, Amitai Armon, 2021, <a href="https://[arxiv.org/pdf/2106.03253.pdf">arxiv:2106.03253</a></p>
<p>[2] XGBoost: A Scalable Tree Boosting System. Tianqi Chen, Carlos Guestrin 2016, <a href="https://arxiv.org/abs/1603.02754">arXiv:1603.02754</a></p>
<p>[3] CatBoost: unbiased boosting with categorical features. Liudmila Prokhorenkova, Gleb Gusev, Aleksandr Vorobev, Anna Veronika Dorogush, Andrey Gulin, <a href="https://arxiv.org/abs/1706.09516">arXiv:1706.09516</a></p>
<p>[4] LightGBM: A Highly Efficient Gradient Boosting Decision Tree. Guolin Ke, Qi Meng, Thomas Finley, Taifeng Wang, 2017, <a href="https://papers.nips.cc/paper/2017/file/6449f44a102fde848669bdd9eb6b76fa-Paper.pdf">31st Conference on Neural Information Processing Systems</a></p>
<p>[5] SAINT: Improved Neural Networks for Tabular Data via Row Attention and Contrastive Pre-Training. Gowthami Somepalli, Micah Goldblum, Avi Schwarzschild, C. Bayan Bruss, Tom Goldstein, 2021, <a href="https://arxiv.org/abs/2106.01342">arXiv:2106.01342</a></p>
<p>[6] Comment Volume Prediction using Neural Networks and Decision Trees, Kamaljot Singh, Ranjeet Kaur, 2015 17th UKSIM-AMSS International Conference on Modelling and Simulation.</p>
<p>[7] TabNet: Attentive Interpretable Tabular Learning, Sercan O. Arik, Tomas Pfister, <a href="https://arxiv.org/abs/1908.07442">arXiv:1908.07442v5</a></p>
<p>[8] Train longer, generalize better: closing the generalization gap in large batch training of neural networks.
Elad Hoffer, Itay Hubara and Daniel Soudry, 2017, <a href="https://arxiv.org/abs/1705.08741">arXiv:1705.08741</a></p>
<p>[9] TabTransformer: Tabular Data Modeling Using Contextual Embeddings. Xin Huang, Ashish Khetan, Milan Cvitkovic, Zohar Karnin, 2020. <a href="https://arxiv.org/abs/2012.06678">arXiv:2012.06678v1</a></p>
<p>[10] Attention Is All You Need, Ashish Vaswani, Noam Shazeer, Niki Parmar, et al., 2017. <a href="https://arxiv.org/abs/1706.03762">arXiv:1706.03762v5</a></p>
<p>[11] Adam: A Method for Stochastic Optimization, Diederik P. Kingma, Jimmy Ba, 2014, <a href="https://arxiv.org/abs/1412.6980">arXiv:1412.6980</a></p>
<p>[12] Decoupled Weight Decay Regularization, Ilya Loshchilov, Frank Hutter, 2017.<a href="https://arxiv.org/abs/1711.05101">arXiv:1711.05101</a></p>
<p>[13] On the Variance of the Adaptive Learning Rate and Beyond, Liyuan Liu, Haoming Jiang, Pengcheng He, Weizhu Chen, Xiaodong Liu, Jianfeng Gao, Jiawei Han, 2019, <a href="https://arxiv.org/abs/1908.03265">arxiv.org:1908.03265</a></p>
<p>[14] Cyclical Learning Rates for Training Neural Networks, Leslie N. Smith, 2017, <a href="https://arxiv.org/abs/1506.01186">arxiv.org:1506.01186</a></p>
<p>[15] Super-Convergence: Very Fast Training of Neural Networks Using Large Learning Rates, Leslie N. Smith, Nicholay Topin, 2017, <a href="https://arxiv.org/abs/1708.07120">arxiv.org:1708.0712</a></p>
<p>[16] Optuna: A Next-generation Hyperparameter Optimization Framework. Takuya Akiba, Shotaro Sano, Toshihiko Yanase, Takeru Ohta, Masanori Koyama, 2019, <a href="https://arxiv.org/abs/1907.10902">arXiv:1907.10902</a></p>
<p>[17] Algorithms for Hyper-Parameter Optimization, James Bergstra, Rémi Bardenet, Yoshua Bengio, Balázs Kégl, 2011, 
<a href="https://papers.nips.cc/paper/2011/file/86e8f7ab32cfd12577bc2619bc635690-Paper.pdf">25th Conference on Neural Information Processing Systems</a></p>
<p>[18] Focal Loss for Dense Object Detection, Tsung-Yi Lin, Priya Goyal, Ross Girshick, Kaiming He, Piotr Dollár, 2017, <a href="https://arxiv.org/abs/1708.02002?source=post_page---------------------------">arxiv.org:1708.02002</a></p>
<p>[19] Wide &amp; Deep Learning for Recommender Systems, Heng-Tze Cheng, Levent Koc, Jeremiah Harmsen, et al, 2016, <a href="https://arxiv.org/abs/1606.07792">arxiv.org:1606.07792</a></p>
<p>[20] FNet: Mixing Tokens with Fourier Transforms, James Lee-Thorp, Joshua Ainslie, Ilya Eckstein, Santiago Ontanon, 2021, <a href="https://arxiv.org/abs/2105.03824">arxiv.org:2105.03824</a></p>
<p>[21] Pay Attention to MLPs, Hanxiao Liu, Zihang Dai, David R. So, Quoc V. Le, 2021, <a href="https://arxiv.org/abs/2105.08050">arxiv.org:2105.08050</a></p>
<p>[22] ResMLP: Feedforward networks for image classification with data-efficient training,
Hugo Touvron, Piotr Bojanowski, Mathilde Caron, et al, 2021, <a href="https://arxiv.org/abs/2105.03404">arxiv.org:2105.03404</a></p>

</div>
</div>
</div>
</div>
 

